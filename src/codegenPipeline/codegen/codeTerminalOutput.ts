import { sortByPackage } from "../utils/filterPackages";
import { packageListFile } from "../utils/packageListJson";
import { cleanupPath } from "./utils/cleanupPath";
import { findModuleImplementation } from "./utils/resolveDefaultExportPath";

const line = (pkgName: string, importPath: string) => `"${pkgName}": ConfigPluginOptions<typeof import("${cleanupPath(importPath)}")["default"]>;`;

const emptyStrArr = (): string[] => [];

export const getConfigPluginTypeCode = async (): Promise<string> => {
    const packageList = (await packageListFile().load()).filter((pkg) => pkg.hasConfigPlugin).sort(sortByPackage);
    const out = {
        errors: new Map<string, string[]>(),
        correct: emptyStrArr(),
        tsIgnored: emptyStrArr(),
        aliased: emptyStrArr(),
        pathOverrides: emptyStrArr(),
        untyped: emptyStrArr(),
    } satisfies Record<string, string[] | Map<string, string[]>>;

    const addError = (pkg: string, error: string) => {
        const packages = out.errors.get(error) || [];
        packages.push(pkg);
        out.errors.set(error, packages);
    };

    for (const { githubUrl, npmPkg, override } of packageList) {
        if (!npmPkg) {
            addError(githubUrl, "no npmPkg:");
            continue;
        }
        try {
            // biome-ignore lint:  lint/complexity/useOptionalChain not possible here (because of false)
            const path = override && override["path"] ? override.path : await findModuleImplementation(npmPkg);
            if (override && override.tsIgnore === true) {
                out.tsIgnored.push("// @ts-expect-error [override]");
                out.tsIgnored.push(line(npmPkg, path));
                override.alias?.forEach((alias) => {
                    out.tsIgnored.push(line(alias, path));
                });
            } // biome-ignore lint:  lint/complexity/useOptionalChain not possible here (because of false)
            else if (override && override.path) {
                out.pathOverrides.push(line(npmPkg, path));
                override.alias?.forEach((alias) => {
                    out.pathOverrides.push(line(alias, path));
                });
            } else if (override === false) {
                out.correct.push(line(npmPkg, path));
            } else if (override?.alias) {
                out.aliased.push(line(npmPkg, path));
                override.alias?.forEach((alias) => {
                    out.aliased.push(line(alias, path));
                });
            } else {
                out.untyped.push("// @ts-expect-error [Package doesn't ship types for app.plugin.js]");
                out.untyped.push(line(npmPkg, path));
                override?.alias?.forEach((alias) => {
                    out.untyped.push(line(alias, path));
                });
            }
        } catch (e) {
            const errorMessage = `${e instanceof Error ? e.message : String(e)}:`;
            addError(npmPkg, errorMessage);
        }
    }

    const template = `
import type { ConfigPluginOptions } from "./types";

// This file is auto-generated by the codegenCli

export interface ThirdPartyAutomatedPlugins {
    // Packages with ts-ignore override:
    ${out.tsIgnored.join("\n    ")}

    // Packages with manual path override:
    ${out.pathOverrides.join("\n    ")}
    
    // Packages with detected types:
    ${out.correct.join("\n    ")}
    
    // Packages with custom alias:
    ${out.aliased.join("\n    ")}
    
    // Packages without types:
    ${out.untyped.join("\n    ")}
    
    /* Errors:
${JSON.stringify([...out.errors.entries()], null, 2)}
    */
}
`;

    return template;
};
