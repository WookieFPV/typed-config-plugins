import { sortByPackage } from "../utils/filterPackages";
import { packageListFile } from "../utils/packageListJson";

const line = (pkgName: string, importPath: string) => `"${pkgName}": ConfigPluginOptions<typeof import("${importPath}")["default"]>;`;

const emptyStrArr = (): string[] => [];

export const getConfigPluginTypeCode = async (): Promise<string> => {
    const packageList = (await packageListFile().load()).filter((pkg) => pkg.hasConfigPlugin && "types" in pkg).sort(sortByPackage);
    const out = {
        errors: new Map<string, string[]>(),
        lines: emptyStrArr(),
        untypedPackages: emptyStrArr(),
    } satisfies Record<string, string[] | Map<string, string[]>>;

    const addError = (pkg: string, error: string) => {
        const packages = out.errors.get(error) || [];
        packages.push(pkg);
        out.errors.set(error, packages);
    };

    for (const { githubUrl, npmPkg, types } of packageList) {
        const override = types?.override ?? {};
        if (!npmPkg) {
            addError(githubUrl, "no npmPkg:");
            continue;
        }
        try {
            const isIgnored = !!override.ignore || (!types?.valid && !override.path);
            const path = override.path ?? types?.path;

            if (types?.error || !path) {
                addError(npmPkg, types?.error ?? "unknown Error");
            } else {
                if (isIgnored) {
                    out.lines.push("// @ts-expect-error [Invalid types or not exported]");
                    out.untypedPackages.push(npmPkg);
                }
                out.lines.push(line(npmPkg, path));

                override.alias?.forEach((alias) => {
                    out.lines.push(line(alias, path));
                });
            }
        } catch (e) {
            const errorMessage = `${e instanceof Error ? e.message : String(e)}:`;
            addError(npmPkg, errorMessage);
        }
    }

    const template = `
import type { ConfigPluginOptions } from "./types";

// This file is auto-generated by the codegenCli

export interface ThirdPartyAutomatedPlugins {
    
    ${out.lines.join("\n    ")}
      
    /* Errors:
${JSON.stringify([...out.errors.entries()], null, 2)}
    */
}
`;

    return template;
};
