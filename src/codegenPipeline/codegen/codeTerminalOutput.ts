import { sortByPackage } from "../utils/filterPackages";
import { packageListFile } from "../utils/packageListJson";
import type { RnDep } from "../utils/types";

const line = (pkgName: string, importPath: string, name = "default") => `"${pkgName}": ConfigPluginOptions<typeof import("${importPath}")["${name}"]>;`;
const linesUntyped = (pkgName: string) => ["// This Packages doesn't ship types for config plugin:", `"${pkgName}": ConfigPluginOptions<unknown>;`];

const emptyStrArr = (): string[] => [];

export const getConfigPluginTypeCode = async (): Promise<string> => {
    const packageList = (await packageListFile().load()).filter((pkg) => pkg.hasConfigPlugin && "types" in pkg).sort(sortByPackage);
    const out = {
        errors: new Map<string, string[]>(),
        lines: emptyStrArr(),
        untypedPackages: emptyStrArr(),
    } satisfies Record<string, string[] | Map<string, string[]>>;

    const addError = (pkg: string, error: string) => {
        const packages = out.errors.get(error) || [];
        packages.push(pkg);
        out.errors.set(error, packages);
    };
    const addIgnoreLine = (types: RnDep["types"], npmPkg: string) => {
        const isIgnored = !!types?.override?.ignore || (!types?.valid && !types?.override?.path);
        if (types?.packageExport) {
            out.lines.push("// @ts-expect-error [Package uses `exports` in `package.json`, which breaks this import]");
            addError(npmPkg, "Package uses `exports` in `package.json`, which breaks this import");
        } else if (isIgnored) {
            out.lines.push("// @ts-expect-error [Invalid types or not exported]");
            out.untypedPackages.push(npmPkg);
        }
    };
    for (const { githubUrl, npmPkg, types } of packageList) {
        const override = types?.override ?? {};
        if (!npmPkg) {
            addError(githubUrl, "no npmPkg:");
            continue;
        }
        try {
            const path = override.path ?? types?.path;
            if (types?.path && override.path === types?.path) addError(npmPkg, "Redundant path override");
            if (types?.valid && override.ignore && !types.packageExport) addError(npmPkg, "Redundant ignore override");

            if ((!types?.override?.path && types?.error) || !path) {
                out.lines.push(...linesUntyped(npmPkg));
                addError(npmPkg, types?.error ?? "unknown Error");
            } else {
                addIgnoreLine(types, npmPkg);
                out.lines.push(line(npmPkg, path, override.name));

                override.alias?.forEach((alias) => {
                    addIgnoreLine(types, npmPkg);
                    out.lines.push(line(alias, path, override.name));
                });
            }
        } catch (e) {
            const errorMessage = `${e instanceof Error ? e.message : String(e)}:`;
            addError(npmPkg, errorMessage);
        }
    }

    const template = `
import type { ConfigPluginOptions } from "./types";

// This file is auto-generated by the codegenCli

export interface ThirdPartyAutomatedPlugins {
    
    ${out.lines.join("\n    ")}
      
    /* Errors:
${JSON.stringify([...out.errors.entries()], null, 2)}
    */
}
`;

    return template;
};
