import { sortByPackage } from "../utils/filterPackages";
import { packageListFile } from "../utils/packageListJson";

const line = (pkgName: string, importPath: string) => `"${pkgName}": ConfigPluginOptions<typeof import("${importPath}")["default"]>;`;

const emptyStrArr = (): string[] => [];

export const getConfigPluginTypeCode = async (): Promise<string> => {
    const packageList = (await packageListFile().load()).filter((pkg) => pkg.hasConfigPlugin && "types" in pkg).sort(sortByPackage);
    const out = {
        errors: new Map<string, string[]>(),
        correct: emptyStrArr(),
        tsIgnored: emptyStrArr(),
        aliased: emptyStrArr(),
        pathOverrides: emptyStrArr(),
        untyped: emptyStrArr(),
        untypedPackages: emptyStrArr(),
    } satisfies Record<string, string[] | Map<string, string[]>>;

    const addError = (pkg: string, error: string) => {
        const packages = out.errors.get(error) || [];
        packages.push(pkg);
        out.errors.set(error, packages);
    };

    for (const { githubUrl, npmPkg, types } of packageList) {
        const override = types?.override ?? {};
        if (!npmPkg) {
            addError(githubUrl, "no npmPkg:");
            continue;
        }
        try {
            const isIgnored = !!override?.ignore;

            const path = override?.path ? override.path : types?.path;
            if (types?.error || !path) {
                addError(npmPkg, types?.error ?? "unknown Error");
            } else if (override?.path) {
                out.pathOverrides.push(line(npmPkg, path));
                override.alias?.forEach((alias) => {
                    out.pathOverrides.push(line(alias, path));
                });
            } else if (override?.alias) {
                out.aliased.push(line(npmPkg, path));
                override.alias?.forEach((alias) => {
                    out.aliased.push(line(alias, path));
                });
            } else if (!isIgnored && types?.valid) {
                out.correct.push(line(npmPkg, path));
            } else {
                out.untyped.push("// @ts-expect-error [Package doesn't ship types for app.plugin.js]");
                out.untyped.push(line(npmPkg, path));
                out.untypedPackages.push(npmPkg);
                if (override)
                    override?.alias?.forEach((alias) => {
                        out.untyped.push(line(alias, path));
                    });
            }
        } catch (e) {
            const errorMessage = `${e instanceof Error ? e.message : String(e)}:`;
            addError(npmPkg, errorMessage);
        }
    }

    const template = `
import type { ConfigPluginOptions } from "./types";

// This file is auto-generated by the codegenCli

export interface ThirdPartyAutomatedPlugins {

    // Packages with manual path override:
    ${out.pathOverrides.join("\n    ")}
    
    // Packages with detected types:
    ${out.correct.join("\n    ")}
    
    // Packages with custom alias:
    ${out.aliased.join("\n    ")}
    
    // Packages without types:
    ${out.untyped.join("\n    ")}
    
    /* Errors:
${JSON.stringify([...out.errors.entries()], null, 2)}
    */
}
`;

    return template;
};
